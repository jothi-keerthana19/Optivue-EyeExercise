<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eye Exercise Tracker - Focus Training</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <style>
        :root {
            --primary-blue: hsl(210, 100%, 60%);
            --success-green: hsl(140, 60%, 45%);
            --warning-amber: hsl(38, 90%, 55%);
            --alert-red: hsl(0, 75%, 60%);
            --bg-light: hsl(210, 20%, 98%);
            --text-primary: hsl(220, 15%, 20%);
            --text-secondary: hsl(220, 10%, 50%);
        }

        body {
            background-color: var(--bg-light);
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
        }

        /* Exercise Area */
        #exercise-area {
            min-height: 500px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        #exercise-area.active {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        }

        /* Exercise Guide Overlay (Repurposed Calibration) */
        #exercise-guide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none;
            z-index: 100;
        }

        #exercise-guide-overlay.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Calibration Point (Now Exercise Guide Dot) */
        #calibration-point {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, hsl(0, 75%, 60%) 0%, hsl(0, 85%, 50%) 100%);
            position: absolute;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
            border: 3px solid white;
            transition: all 0.4s ease-in-out;
            z-index: 101;
            display: none;
        }

        #calibration-point.active {
            display: block;
            animation: pulse-dot 1.5s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.15); }
        }

        /* Camera Container */
        #camera-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 3px solid var(--primary-blue);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            background: #000;
            z-index: 1000;
            display: none;
        }

        #camera-container.active {
            display: block;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas {
            display: none;
        }

        /* Notification Alert */
        #notification-alert {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: none;
            min-width: 400px;
        }

        #notification-alert.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        /* Exercise List */
        .exercise-item {
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .exercise-item:hover {
            background-color: hsl(210, 15%, 95%);
            transform: translateX(4px);
        }

        .exercise-item.active {
            background-color: var(--primary-blue);
            color: white;
            border-left: 4px solid hsl(210, 100%, 45%);
        }

        /* Summary Cards */
        .summary-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s;
        }

        .summary-card:hover {
            transform: translateY(-2px);
        }

        .summary-metric {
            font-size: 3rem;
            font-weight: 700;
            color: var(--primary-blue);
        }

        .summary-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Buttons */
        .btn-custom {
            min-height: 48px;
            border-radius: 8px;
            font-weight: 500;
        }

        /* Ready State Display */
        #ready-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 2rem;
        }

        /* Focus Status Badge */
        #focus-status-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            z-index: 50;
            backdrop-filter: blur(8px);
        }

        #focus-status-badge.focused {
            background-color: rgba(42, 157, 143, 0.9);
            color: white;
        }

        #focus-status-badge.not-focused {
            background-color: rgba(231, 111, 81, 0.9);
            color: white;
            animation: pulse-alert 1s infinite;
        }

        @keyframes pulse-alert {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(231, 111, 81, 0.7);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px 10px rgba(231, 111, 81, 0);
            }
        }
    </style>
</head>
<body>
    <!-- Notification Alert -->
    <div id="notification-alert" class="alert alert-warning alert-dismissible fade" role="alert">
        <i class="bi bi-exclamation-triangle me-2"></i>
        <span id="notification-message">User not detected. Please stay in the camera view.</span>
        <button type="button" class="btn-close" onclick="hideNotification()"></button>
    </div>

    <div class="container-fluid mt-4">
        <!-- Header -->
        <div class="row mb-4">
            <div class="col-12 text-center">
                <i class="bi bi-eye-fill" style="font-size: 3rem; color: var(--primary-blue);"></i>
                <h1 class="mt-2 mb-2">Eye Exercise Tracker</h1>
                <p class="text-secondary">Focus training exercises to reduce eye strain and improve eye health</p>
            </div>
        </div>

        <div class="row">
            <!-- Exercise List Sidebar -->
            <div class="col-md-4">
                <div class="card shadow-sm mb-4">
                    <div class="card-header bg-white">
                        <h5 class="mb-0"><i class="bi bi-list-ul me-2"></i>Exercise Types</h5>
                    </div>
                    <div class="card-body">
                        <div class="exercise-item p-3" data-exercise="9-point" onclick="selectExercise('9-point')">
                            <div class="d-flex align-items-center">
                                <i class="bi bi-grid-3x3 me-3" style="font-size: 1.5rem;"></i>
                                <div>
                                    <h6 class="mb-0">9-Point Focus</h6>
                                    <small class="text-muted">Follow the dot through 9 positions</small>
                                </div>
                            </div>
                        </div>
                        <div class="exercise-item p-3" data-exercise="circular" onclick="selectExercise('circular')">
                            <div class="d-flex align-items-center">
                                <i class="bi bi-circle me-3" style="font-size: 1.5rem;"></i>
                                <div>
                                    <h6 class="mb-0">Circular Motion</h6>
                                    <small class="text-muted">Follow circular eye movement</small>
                                </div>
                            </div>
                        </div>
                        <div class="exercise-item p-3" data-exercise="horizontal" onclick="selectExercise('horizontal')">
                            <div class="d-flex align-items-center">
                                <i class="bi bi-arrows-expand me-3" style="font-size: 1.5rem;"></i>
                                <div>
                                    <h6 class="mb-0">Horizontal Sweep</h6>
                                    <small class="text-muted">Left to right eye movement</small>
                                </div>
                            </div>
                        </div>
                        <div class="exercise-item p-3" data-exercise="vertical" onclick="selectExercise('vertical')">
                            <div class="d-flex align-items-center">
                                <i class="bi bi-arrow-down-up me-3" style="font-size: 1.5rem;"></i>
                                <div>
                                    <h6 class="mb-0">Vertical Sweep</h6>
                                    <small class="text-muted">Up and down eye movement</small>
                                </div>
                            </div>
                        </div>
                        <div class="exercise-item p-3" data-exercise="figure-eight" onclick="selectExercise('figure-eight')">
                            <div class="d-flex align-items-center">
                                <i class="bi bi-infinity me-3" style="font-size: 1.5rem;"></i>
                                <div>
                                    <h6 class="mb-0">Figure Eight</h6>
                                    <small class="text-muted">Infinity pattern movement</small>
                                </div>
                            </div>
                        </div>
                        <div class="exercise-item p-3" data-exercise="diagonal-sweep" onclick="selectExercise('diagonal-sweep')">
                            <div class="d-flex align-items-center">
                                <i class="bi bi-slash-lg me-3" style="font-size: 1.5rem;"></i>
                                <div>
                                    <h6 class="mb-0">Diagonal Sweep</h6>
                                    <small class="text-muted">Diagonal eye movement patterns</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Control Panel -->
                <div class="card shadow-sm">
                    <div class="card-header bg-white">
                        <h5 class="mb-0"><i class="bi bi-gear me-2"></i>Controls</h5>
                    </div>
                    <div class="card-body">
                        <div class="form-check form-switch mb-3">
                            <input class="form-check-input" type="checkbox" id="trackingToggle" onchange="toggleTracking()">
                            <label class="form-check-label" for="trackingToggle">
                                <i class="bi bi-camera-video me-1"></i>Enable Focus Tracking
                            </label>
                        </div>

                        <div class="mb-3">
                            <button id="voice-toggle-btn" class="btn btn-primary w-100" onclick="toggleVoiceNotifications()">
                                <i class="bi bi-volume-up-fill me-2"></i>Voice Notifications Enabled
                            </button>
                            <small class="text-muted d-block mt-1">
                                <i class="bi bi-info-circle me-1"></i>Get audio alerts when you lose focus
                            </small>
                        </div>

                        <div class="d-grid gap-2">
                            <button id="startBtn" class="btn btn-primary btn-custom" onclick="startExercise()" disabled>
                                <i class="bi bi-play-fill me-2"></i>Start Exercise
                            </button>
                            <button id="pauseBtn" class="btn btn-warning btn-custom" onclick="pauseExercise()" disabled>
                                <i class="bi bi-pause-fill me-2"></i>Pause
                            </button>
                            <button id="stopBtn" class="btn btn-danger btn-custom" onclick="stopExercise()" disabled>
                                <i class="bi bi-stop-fill me-2"></i>Stop
                            </button>
                        </div>

                        <div class="mt-3">
                            <small class="text-muted">
                                <i class="bi bi-info-circle me-1"></i>
                                Exercise Timer: <span id="timer-display" class="fw-bold">00:00</span>
                            </small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Exercise Area -->
            <div class="col-md-8">
                <div class="card shadow-sm">
                    <div class="card-header bg-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="bi bi-bullseye me-2"></i>Exercise Area</h5>
                        <span class="badge bg-secondary" id="status-badge">Ready</span>
                    </div>
                    <div class="card-body p-0" style="position: relative;">
                        <div id="exercise-area">
                            <!-- Ready State -->
                            <div id="ready-state">
                                <i class="bi bi-eye-fill" style="font-size: 4rem; color: var(--primary-blue);"></i>
                                <h3 class="mt-3">Ready to Begin</h3>
                                <p class="text-secondary">Select an exercise and enable focus tracking to start</p>
                            </div>

                            <!-- Exercise Guide Overlay -->
                            <div id="exercise-guide-overlay">
                                <div id="calibration-point"></div>
                                <div id="guide-text" class="text-center" style="position: absolute; bottom: 2rem;">
                                    <h4>Follow the dot with your eyes</h4>
                                    <p class="text-muted">Keep your head steady</p>
                                </div>
                            </div>

                            <!-- Focus Status Badge -->
                            <div id="focus-status-badge" style="display: none;">
                                <i class="bi bi-eye-fill me-1"></i>
                                <span id="focus-status-text">Focused</span>
                            </div>

                            <!-- Summary Container (shown after exercise) -->
                            <div id="summary-container" style="display: none; padding: 2rem;">
                                <h3 class="text-center mb-4">Exercise Complete!</h3>
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <div class="summary-card text-center">
                                            <i class="bi bi-percent" style="font-size: 2rem; color: var(--primary-blue);"></i>
                                            <div class="summary-metric" id="focus-performance">0%</div>
                                            <div class="summary-label">Focus Performance</div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="summary-card text-center">
                                            <i class="bi bi-clock-history" style="font-size: 2rem; color: var(--success-green);"></i>
                                            <div class="summary-metric" id="focus-time">0:00</div>
                                            <div class="summary-label">Total Focus Time</div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="summary-card text-center">
                                            <i class="bi bi-trophy" style="font-size: 2rem; color: var(--warning-amber);"></i>
                                            <div class="summary-metric" id="best-streak">0s</div>
                                            <div class="summary-label">Best Focus Streak</div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="summary-card text-center">
                                            <i class="bi bi-exclamation-triangle" style="font-size: 2rem; color: var(--alert-red);"></i>
                                            <div class="summary-metric" id="distractions-count">0</div>
                                            <div class="summary-label">Distractions</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="text-center mt-4">
                                    <button class="btn btn-primary btn-custom" onclick="resetExercise()">
                                        <i class="bi bi-arrow-clockwise me-2"></i>Start New Exercise
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Camera Preview -->
    <div id="camera-container">
        <img id="video" alt="Camera Feed" style="display: none;" />
        <canvas id="video-canvas"></canvas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Application State
        const AppState = {
            IDLE: 'idle',
            RUNNING: 'running',
            PAUSED: 'paused',
            COMPLETED: 'completed'
        };

        let currentState = AppState.IDLE;
        let selectedExercise = null;
        let trackingEnabled = false;
        let pollingInterval = null;
        let exerciseInterval = null;
        let timerInterval = null;
        let consecutiveFailures = 0;
        const MAX_CONSECUTIVE_FAILURES = 2;

        // Metrics
        let focusTime = 0;
        let distractions = 0;
        let currentFocusStreak = 0;
        let maxFocusStreak = 0;
        let totalExerciseDuration = 0;
        let wasFocused = true;
        let exerciseStartTime = 0;

        // Exercise Patterns
        const exerciseConfig = {
            '9-point': { duration: 60, holdTime: 1500, transitionTime: 400 },
            'circular': { duration: 45, holdTime: 800, transitionTime: 300 },
            'horizontal': { duration: 45, holdTime: 800, transitionTime: 300 },
            'vertical': { duration: 45, holdTime: 800, transitionTime: 300 },
            'figure-eight': { duration: 60, holdTime: 1000, transitionTime: 400 },
            'diagonal-sweep': { duration: 60, holdTime: 1000, transitionTime: 400 }
        };

        const exercisePatterns = {
            '9-point': [
                { x: 20, y: 20 }, { x: 50, y: 20 }, { x: 80, y: 20 },
                { x: 80, y: 50 }, { x: 80, y: 80 }, { x: 50, y: 80 },
                { x: 20, y: 80 }, { x: 20, y: 50 }, { x: 50, y: 50 }
            ],
            'circular': generateCircularPattern(50, 50, 30, 16),
            'horizontal': [
                { x: 15, y: 50 }, { x: 25, y: 50 }, { x: 35, y: 50 }, { x: 45, y: 50 },
                { x: 55, y: 50 }, { x: 65, y: 50 }, { x: 75, y: 50 }, { x: 85, y: 50 },
                { x: 75, y: 50 }, { x: 65, y: 50 }, { x: 55, y: 50 }, { x: 45, y: 50 },
                { x: 35, y: 50 }, { x: 25, y: 50 }, { x: 15, y: 50 }
            ],
            'vertical': [
                { x: 50, y: 15 }, { x: 50, y: 25 }, { x: 50, y: 35 }, { x: 50, y: 45 },
                { x: 50, y: 55 }, { x: 50, y: 65 }, { x: 50, y: 75 }, { x: 50, y: 85 },
                { x: 50, y: 75 }, { x: 50, y: 65 }, { x: 50, y: 55 }, { x: 50, y: 45 },
                { x: 50, y: 35 }, { x: 50, y: 25 }, { x: 50, y: 15 }
            ],
            'figure-eight': generateFigureEightPattern(50, 50, 25, 20),
            'diagonal-sweep': [
                { x: 20, y: 20 }, { x: 30, y: 30 }, { x: 40, y: 40 }, { x: 50, y: 50 },
                { x: 60, y: 60 }, { x: 70, y: 70 }, { x: 80, y: 80 },
                { x: 70, y: 70 }, { x: 60, y: 60 }, { x: 50, y: 50 }, { x: 40, y: 40 },
                { x: 30, y: 30 }, { x: 20, y: 20 },
                { x: 80, y: 20 }, { x: 70, y: 30 }, { x: 60, y: 40 }, { x: 50, y: 50 },
                { x: 40, y: 60 }, { x: 30, y: 70 }, { x: 20, y: 80 },
                { x: 30, y: 70 }, { x: 40, y: 60 }, { x: 50, y: 50 }, { x: 60, y: 40 },
                { x: 70, y: 30 }, { x: 80, y: 20 }
            ]
        };

        function generateCircularPattern(cx, cy, radius, points) {
            const pattern = [];
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * 2 * Math.PI;
                pattern.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }
            return pattern;
        }

        function generateFigureEightPattern(cx, cy, width, height) {
            const pattern = [];
            const points = 24;
            for (let i = 0; i < points; i++) {
                const t = (i / points) * 2 * Math.PI;
                const x = cx + (width * Math.sin(t));
                const y = cy + (height * Math.sin(t) * Math.cos(t));
                pattern.push({ x, y });
            }
            return pattern;
        }

        function selectExercise(exercise) {
            selectedExercise = exercise;

            document.querySelectorAll('.exercise-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`[data-exercise="${exercise}"]`).classList.add('active');

            if (trackingEnabled) {
                document.getElementById('startBtn').disabled = false;
            }
        }

        let videoStream = null;
        let videoElement = null;
        let canvasElement = null;
        let displayCanvas = null;
        let displayCtx = null;

        async function toggleTracking() {
            const toggle = document.getElementById('trackingToggle');
            trackingEnabled = toggle.checked;

            if (trackingEnabled) {
                try {
                    // Request browser camera access
                    videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user'
                        } 
                    });

                    // Create video element if it doesn't exist
                    if (!videoElement) {
                        videoElement = document.createElement('video');
                        videoElement.autoplay = true;
                        videoElement.playsInline = true;
                        videoElement.muted = true;
                        videoElement.style.display = 'none';
                        document.body.appendChild(videoElement);
                    }

                    if (!canvasElement) {
                        canvasElement = document.createElement('canvas');
                        canvasElement.width = 640;
                        canvasElement.height = 480;
                        canvasElement.style.display = 'none';
                        document.body.appendChild(canvasElement);
                    }

                    // Get display canvas for showing the camera feed
                    displayCanvas = document.getElementById('video-canvas');
                    displayCanvas.width = 320;
                    displayCanvas.height = 240;
                    displayCtx = displayCanvas.getContext('2d');

                    videoElement.srcObject = videoStream;

                    // Wait for video to be FULLY ready with actual pixel data
                    await new Promise((resolve) => {
                        let framesChecked = 0;
                        const maxFrameChecks = 50; // Wait up to 5 seconds

                        const checkForActualFrames = () => {
                            if (!canvasElement || !videoElement) return;

                            const ctx = canvasElement.getContext('2d');
                            ctx.drawImage(videoElement, 0, 0, 640, 480);

                            // Check multiple pixels to ensure we have real video data
                            const imageData = ctx.getImageData(0, 0, 640, 480);
                            let nonZeroPixels = 0;
                            
                            // Sample every 100th pixel
                            for (let i = 0; i < imageData.data.length; i += 400) {
                                if (imageData.data[i] > 0 || imageData.data[i+1] > 0 || imageData.data[i+2] > 0) {
                                    nonZeroPixels++;
                                }
                            }

                            // Need at least 10% of sampled pixels to be non-black
                            if (nonZeroPixels > (imageData.data.length / 4000)) {
                                // We have actual video data!
                                console.log('Video element has actual frame data');
                                resolve();
                            } else {
                                framesChecked++;
                                if (framesChecked >= maxFrameChecks) {
                                    console.warn('Video started but frames may still be initializing');
                                    resolve(); // Continue anyway after timeout
                                } else {
                                    setTimeout(checkForActualFrames, 100);
                                }
                            }
                        };

                        videoElement.onloadedmetadata = () => {
                            videoElement.play().then(() => {
                                // Wait longer for frames to stabilize
                                setTimeout(checkForActualFrames, 500);
                            });
                        };
                    });

                    // Show the camera container with the backend processed feed
                    document.getElementById('camera-container').classList.add('active');

                    // Start rendering live video
                    renderLiveVideo();

                    // Start sending frames to backend and polling for results
                    startFrameCapture();
                    startFocusPolling();

                    if (selectedExercise) {
                        document.getElementById('startBtn').disabled = false;
                    }

                    showNotification('Camera started successfully!', 'success');
                    setTimeout(hideNotification, 2000);
                } catch (error) {
                    console.error('Error starting camera:', error);
                    toggle.checked = false;
                    trackingEnabled = false;
                    showNotification('Failed to access camera. Please ensure camera permissions are granted.', 'danger');
                }
            } else {
                // Stop camera stream
                stopFrameCapture();
                stopFocusPolling();
                stopLiveVideo();

                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = null;
                }

                if (displayCanvas) {
                    displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
                }

                document.getElementById('camera-container').classList.remove('active');
                document.getElementById('startBtn').disabled = true;
            }
        }

        let renderInterval = null;
        let lastDetectionData = null;

        function renderLiveVideo() {
            if (renderInterval) return;

            renderInterval = setInterval(() => {
                if (!videoElement || !displayCanvas || !trackingEnabled) return;

                if (videoElement.readyState >= 2) {
                    // Draw video frame
                    displayCtx.drawImage(videoElement, 0, 0, 320, 240);

                    // Draw bounding box if face detected
                    if (lastDetectionData && lastDetectionData.face_detected && lastDetectionData.bbox) {
                        const bbox = lastDetectionData.bbox;
                        // Scale coordinates to display canvas size
                        const scaleX = 320 / 640;
                        const scaleY = 240 / 480;
                        
                        const x = bbox.x * scaleX;
                        const y = bbox.y * scaleY;
                        const width = bbox.width * scaleX;
                        const height = bbox.height * scaleY;

                        // Draw bounding box
                        displayCtx.strokeStyle = '#00FF00';
                        displayCtx.lineWidth = 3;
                        displayCtx.strokeRect(x, y, width, height);

                        // Draw confidence text
                        displayCtx.fillStyle = '#00FF00';
                        displayCtx.font = 'bold 14px Arial';
                        displayCtx.fillText('Face Detected', x, y - 5);
                    }
                }
            }, 33); // ~30 FPS
        }

        function stopLiveVideo() {
            if (renderInterval) {
                clearInterval(renderInterval);
                renderInterval = null;
            }
        }

        let frameCaptureInterval = null;
        let framesSent = 0;

        function startFrameCapture() {
            if (frameCaptureInterval) return;

            // Wait 1 second before starting to send frames
            setTimeout(() => {
                frameCaptureInterval = setInterval(async () => {
                    if (!videoElement || !canvasElement || !trackingEnabled) return;

                    // Double-check video is ready with actual frame data
                    if (videoElement.readyState < 3) {
                        console.log('Video not ready yet, skipping frame');
                        return;
                    }

                    try {
                        const ctx = canvasElement.getContext('2d', { willReadFrequently: true });

                        // Draw current video frame to canvas
                        ctx.drawImage(videoElement, 0, 0, 640, 480);

                        // More thorough validation - check multiple pixels
                        let totalPixelValue = 0;
                        let validPixels = 0;
                        
                        for (let i = 0; i < 10; i++) {
                            const x = Math.floor(Math.random() * 640);
                            const y = Math.floor(Math.random() * 480);
                            const imageData = ctx.getImageData(x, y, 1, 1);
                            const pixelSum = imageData.data[0] + imageData.data[1] + imageData.data[2];
                            totalPixelValue += pixelSum;
                            if (pixelSum > 0) validPixels++;
                        }

                        // Need at least 50% of sampled pixels to be non-black
                        if (validPixels < 5) {
                            console.log('Canvas appears to be black, skipping frame');
                            return;
                        }

                        // Convert canvas to blob and send to backend
                        canvasElement.toBlob(async (blob) => {
                            if (!blob || blob.size === 0 || blob.size < 1000) {
                                console.warn('Invalid blob created from canvas');
                                return;
                            }

                            const formData = new FormData();
                            formData.append('frame', blob, 'frame.jpg');

                            try {
                                const response = await fetch('/api/enhanced-eye-tracking/process_frame', {
                                    method: 'POST',
                                    body: formData
                                });

                                if (!response.ok) {
                                    const errorText = await response.text();
                                    console.error('Frame processing failed:', response.status, errorText);
                                }
                            } catch (error) {
                                console.error('Error sending frame:', error);
                            }
                        }, 'image/jpeg', 0.95);
                    } catch (error) {
                        console.error('Error capturing frame:', error);
                    }
                }, 500); // Send frames every 500ms for better stability
            }, 1000); // Wait 1 second before starting
        }

        function stopFrameCapture() {
            if (frameCaptureInterval) {
                clearInterval(frameCaptureInterval);
                frameCaptureInterval = null;
            }
        }

        function startFocusPolling() {
            if (pollingInterval) return;

            // Poll the backend's detection endpoint instead of sending frames
            pollingInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/enhanced-eye-tracking/get_enhanced_gaze');

                    if (!response.ok) {
                        console.error('Focus polling failed:', response.status);
                        return;
                    }

                    const data = await response.json();
                    handleFocusData(data);

                } catch (error) {
                    console.error('Focus polling error:', error);
                }
            }, 600); // Slower polling for better stability
        }

        function stopFocusPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }

        function handleFocusData(data) {
            const faceDetected = data.face_detected;
            const statusBadge = document.getElementById('focus-status-badge');
            const statusText = document.getElementById('focus-status-text');

            // Store detection data for rendering
            lastDetectionData = data;

            if (faceDetected) {
                consecutiveFailures = 0;

                // Only count focus time when exercise is running
                if (currentState === AppState.RUNNING) {
                    focusTime++;
                    currentFocusStreak++;

                    if (currentFocusStreak > maxFocusStreak) {
                        maxFocusStreak = currentFocusStreak;
                    }
                }

                statusBadge.className = 'focused';
                statusText.textContent = 'Face Detected';
                hideNotification();

                if (!wasFocused) {
                    wasFocused = true;
                    // Welcome back notification
                    if (currentState === AppState.RUNNING) {
                        showNotification('Great! You\'re back on track.', 'success');
                        speakNotification('Good, keep focusing');
                        setTimeout(hideNotification, 2000);
                    }
                }
            } else {
                consecutiveFailures++;

                // Trigger distraction after consecutive failures
                if (consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {
                    if (wasFocused && currentState === AppState.RUNNING) {
                        distractions++;

                        // Save current streak if it's the best
                        if (currentFocusStreak > maxFocusStreak) {
                            maxFocusStreak = currentFocusStreak;
                        }
                        currentFocusStreak = 0;
                        wasFocused = false;
                    }

                    if (currentState === AppState.RUNNING) {
                        showNotification('⚠️ Please refocus! Keep your face in view of the camera.', 'danger');
                    } else {
                        showNotification('Face not detected. Please look at the camera.', 'warning');
                    }

                    statusBadge.className = 'not-focused';
                    statusText.textContent = 'Face Not Detected';
                }
            }
        }

        async function startExercise() {
            if (!selectedExercise) {
                alert('Please select an exercise first');
                return;
            }

            if (currentState === AppState.PAUSED) {
                currentState = AppState.RUNNING;
                document.getElementById('status-badge').textContent = 'Running';
                document.getElementById('status-badge').className = 'badge bg-success';
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('startBtn').disabled = true;
                continueExercise();
                return;
            }

            currentState = AppState.RUNNING;
            resetMetrics();

            document.getElementById('ready-state').style.display = 'none';
            document.getElementById('summary-container').style.display = 'none';
            document.getElementById('exercise-area').classList.add('active');
            document.getElementById('exercise-guide-overlay').classList.add('active');
            document.getElementById('focus-status-badge').style.display = 'block';
            document.getElementById('status-badge').textContent = 'Running';
            document.getElementById('status-badge').className = 'badge bg-success';

            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('stopBtn').disabled = false;

            await countdown();

            exerciseStartTime = Date.now();
            startTimer();
            runExercisePattern();
        }

        function countdown() {
            return new Promise((resolve) => {
                const guideText = document.getElementById('guide-text');
                let count = 3;

                speakNotification('Get ready. Exercise starting in 3, 2, 1');

                const countInterval = setInterval(() => {
                    if (count > 0) {
                        guideText.innerHTML = `<h1>${count}</h1><p>Get ready...</p>`;
                        count--;
                    } else {
                        clearInterval(countInterval);
                        guideText.innerHTML = '<h4>Follow the dot with your eyes</h4><p class="text-muted">Keep your head steady</p>';
                        speakNotification('Begin. Follow the dot with your eyes');
                        resolve();
                    }
                }, 1000);
            });
        }

        async function runExercisePattern() {
            const pattern = exercisePatterns[selectedExercise];
            const config = exerciseConfig[selectedExercise];
            const dot = document.getElementById('calibration-point');
            const area = document.getElementById('exercise-area');
            const areaRect = area.getBoundingClientRect();

            dot.classList.add('active');

            const exerciseDuration = config.duration * 1000;
            const startTime = Date.now();

            while (currentState === AppState.RUNNING) {
                const elapsed = Date.now() - startTime;

                if (elapsed >= exerciseDuration) {
                    completeExercise();
                    break;
                }

                for (let i = 0; i < pattern.length; i++) {
                    if (currentState !== AppState.RUNNING) {
                        break;
                    }

                    const point = pattern[i];
                    const x = (point.x / 100) * areaRect.width;
                    const y = (point.y / 100) * areaRect.height;

                    dot.style.transition = `all ${config.transitionTime}ms ease-in-out`;
                    dot.style.left = `${x}px`;
                    dot.style.top = `${y}px`;

                    await sleep(config.holdTime);

                    if (Date.now() - startTime >= exerciseDuration) {
                        completeExercise();
                        return;
                    }
                }
            }
        }

        function continueExercise() {
            runExercisePattern();
        }

        function pauseExercise() {
            if (currentState === AppState.RUNNING) {
                currentState = AppState.PAUSED;
                document.getElementById('status-badge').textContent = 'Paused';
                document.getElementById('status-badge').className = 'badge bg-warning';
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('startBtn').disabled = false;
                stopTimer();
            }
        }

        function stopExercise() {
            currentState = AppState.IDLE;
            resetExercise();
        }

        function completeExercise() {
            currentState = AppState.COMPLETED;
            stopTimer();

            document.getElementById('exercise-guide-overlay').classList.remove('active');
            document.getElementById('calibration-point').classList.remove('active');
            document.getElementById('focus-status-badge').style.display = 'none';

            totalExerciseDuration = Math.floor((Date.now() - exerciseStartTime) / 100);

            speakNotification('Exercise complete. Well done!');
            showSummary();
        }

        function showSummary() {
            // Calculate total exercise duration in deciseconds (focusTime is in 500ms intervals)
            totalExerciseDuration = Math.floor((Date.now() - exerciseStartTime) / 500);

            const focusPerformance = totalExerciseDuration > 0 
                ? Math.round((focusTime / totalExerciseDuration) * 100)
                : 0;

            // focusTime is counted in 500ms intervals
            const focusTimeSeconds = Math.floor((focusTime * 500) / 1000);
            const focusTimeMinutes = Math.floor(focusTimeSeconds / 60);
            const focusTimeRemainder = focusTimeSeconds % 60;
            const focusTimeStr = `${focusTimeMinutes}:${focusTimeRemainder.toString().padStart(2, '0')}`;

            // currentFocusStreak is in 500ms intervals
            const maxStreakSeconds = Math.floor((maxFocusStreak * 500) / 1000);

            document.getElementById('focus-performance').textContent = `${focusPerformance}%`;
            document.getElementById('focus-time').textContent = focusTimeStr;
            document.getElementById('best-streak').textContent = `${maxStreakSeconds}s`;
            document.getElementById('distractions-count').textContent = distractions;

            document.getElementById('summary-container').style.display = 'block';
            document.getElementById('status-badge').textContent = 'Completed';
            document.getElementById('status-badge').className = 'badge bg-success';
        }

        function resetExercise() {
            currentState = AppState.IDLE;
            resetMetrics();

            document.getElementById('exercise-area').classList.remove('active');
            document.getElementById('exercise-guide-overlay').classList.remove('active');
            document.getElementById('calibration-point').classList.remove('active');
            document.getElementById('focus-status-badge').style.display = 'none';
            document.getElementById('ready-state').style.display = 'flex';
            document.getElementById('summary-container').style.display = 'none';
            document.getElementById('status-badge').textContent = 'Ready';
            document.getElementById('status-badge').className = 'badge bg-secondary';

            document.getElementById('startBtn').disabled = !selectedExercise || !trackingEnabled;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;

            document.getElementById('timer-display').textContent = '00:00';
            stopTimer();
        }

        function resetMetrics() {
            focusTime = 0;
            distractions = 0;
            currentFocusStreak = 0;
            maxFocusStreak = 0;
            totalExerciseDuration = 0;
            wasFocused = true;
            consecutiveFailures = 0;
        }

        function startTimer() {
            const totalSeconds = exerciseConfig[selectedExercise].duration;
            let remainingSeconds = totalSeconds;

            timerInterval = setInterval(() => {
                if (currentState === AppState.RUNNING) {
                    remainingSeconds--;

                    if (remainingSeconds <= 0) {
                        remainingSeconds = 0;
                    }

                    const minutes = Math.floor(remainingSeconds / 60);
                    const secs = remainingSeconds % 60;
                    document.getElementById('timer-display').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Voice notification system
        let voiceEnabled = true;
        let lastVoiceNotification = 0;
        const VOICE_COOLDOWN = 5000; // 5 seconds between voice notifications

        function speakNotification(message) {
            if (!voiceEnabled) return;
            
            const now = Date.now();
            if (now - lastVoiceNotification < VOICE_COOLDOWN) return;
            
            lastVoiceNotification = now;

            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(message);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 0.8;
            
            // Use a clear, calm voice if available
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice = voices.find(voice => 
                voice.lang.startsWith('en') && 
                (voice.name.includes('Google') || voice.name.includes('Microsoft'))
            );
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        function toggleVoiceNotifications() {
            voiceEnabled = !voiceEnabled;
            const btn = document.getElementById('voice-toggle-btn');
            const icon = btn.querySelector('i');
            
            if (voiceEnabled) {
                icon.className = 'bi bi-volume-up-fill';
                btn.classList.remove('btn-outline-secondary');
                btn.classList.add('btn-primary');
                showNotification('Voice notifications enabled', 'success');
                speakNotification('Voice notifications are now enabled');
            } else {
                icon.className = 'bi bi-volume-mute-fill';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-secondary');
                showNotification('Voice notifications disabled', 'info');
                window.speechSynthesis.cancel();
            }
            
            setTimeout(hideNotification, 2000);
        }

        function showNotification(message, type = 'warning') {
            const alert = document.getElementById('notification-alert');
            document.getElementById('notification-message').textContent = message;

            // Update alert class based on type
            alert.className = `alert alert-${type} alert-dismissible fade show`;

            // Update icon based on type
            const icon = type === 'success' ? 'bi-check-circle' : 
                        type === 'danger' ? 'bi-exclamation-triangle' : 
                        type === 'info' ? 'bi-info-circle' :
                        'bi-exclamation-triangle';

            const messageElement = document.getElementById('notification-message');
            messageElement.innerHTML = `<i class="bi ${icon} me-2"></i>${message}`;

            // Trigger voice notification for warnings and errors during exercise
            if ((type === 'warning' || type === 'danger') && currentState === AppState.RUNNING) {
                speakNotification(message);
            }
        }

        function hideNotification() {
            const alert = document.getElementById('notification-alert');
            alert.classList.remove('show');
        }

        // Load voices when available
        if (window.speechSynthesis) {
            window.speechSynthesis.onvoiceschanged = () => {
                window.speechSynthesis.getVoices();
            };
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('Eye Exercise Tracker initialized');
        });
    </script>
</body>
</html>